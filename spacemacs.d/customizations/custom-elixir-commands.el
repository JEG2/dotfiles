;; Commands

(defun jeg2/toggle-elixir-do-blocks ()
  "Toggle between one-line and multi-line do blocks (with an optional else)."
  (interactive)
  (while (and (not (looking-at "\\(?:,\sdo:\\|\sdo$\\)"))
              (> (point) (point-min)))
    (backward-char))
  (cond ((looking-at ",\sdo:")
         (delete-char 1)
         (while (not (looking-at ":"))
           (forward-char))
         (delete-char 1)
         (jeg2/trim-forwards)
         (newline)
         (indent-for-tab-command)
         (while (and (not (looking-at "\\(?:,\selse:\\|$\\)"))
                     (< (point) (point-max)))
           (forward-char))
         (when (looking-at ",\selse:")
           (delete-char 2)
           (newline)
           (forward-char 4)
           (delete-char 1)
           (indent-for-tab-command)
           (jeg2/trim-forwards)
           (newline)
           (unless (eolp) (move-end-of-line nil))
           (indent-for-tab-command))
         (newline)
         (insert "end")
         (indent-for-tab-command)
         (previous-line)
         (unless (eolp) (move-end-of-line nil)))
        ((looking-at "\sdo$")
         (insert ",")
         (while (not (looking-at "do"))
           (forward-char))
         (forward-char 2)
         (insert ": ")
         (jeg2/trim-forwards)
         (unless (eolp) (move-end-of-line nil))
         (jeg2/trim-forwards)
         (when (looking-at "else\\>")
           (insert ", ")
           (forward-char 4)
           (insert ": ")
           (jeg2/trim-forwards)
           (unless (eolp) (move-end-of-line nil))
           (jeg2/trim-forwards))
         (when (looking-at "end\\>") (delete-char 3)))))

(defun jeg2/toggle-elixir-function-syntax ()
  "Toggle between shortcut and long form function syntax."
  (interactive)
  (while (and (not (looking-at "\\(?:&(\\|\\<fn\\>\\)"))
              (> (point) (point-min)))
    (backward-char))
  (cond ((looking-at "&(")
         (delete-char 2)
         (insert "fn -> ")
         (let ((nesting 0))
           (while (and (not (and (looking-at ")") (eq nesting 0)))
                       (< (point) (point-max)))
             (cond ((looking-at "(")
                    (setq nesting (+ nesting 1)))
                   ((looking-at ")")
                    (setq nesting (- nesting 1))))
             (forward-char)))
         (delete-char 1)
         (insert " end")
         (while (and (not (looking-at "->"))
                     (> (point) (point-min)))
           (backward-char)))
        ((looking-at "\\<fn\\>")
         (delete-char 2)
         (let ((params '()))
           (while (and (not (looking-at "->"))
                       (< (point) (point-max)))
             (cond ((looking-at "\\<\\w+\\>")
                    (setq params
                          (append params
                                  (list
                                   (buffer-substring (match-beginning 0)
                                                     (match-end 0)))))
                    (message "%s" params)
                    (delete-char (string-width (car (last params)))))
                   (t
                    (delete-char 1))))
           (delete-char 2)
           (jeg2/trim-forwards)
           (insert "&(")
           (while (and (not (looking-at "\\<end\\>"))
                       (< (point) (point-max)))
             (cond ((and
                     (looking-at "\\<\\w+\\>")
                     (member (buffer-substring (match-beginning 0)
                                               (match-end 0)) params))
                    (let ((param (buffer-substring (match-beginning 0)
                                                   (match-end 0))))
                      (delete-char (string-width param))
                      (insert
                       (concat "&"
                               (number-to-string
                                (1+
                                 (- (length params)
                                    (length (member param params)))))))))
                   (t
                    (forward-char)))))
         (delete-char 3)
         (insert ")")
         (backward-char)
         (jeg2/trim-backwards))))

;; Helper Functions

(defun jeg2/elixir-module-name ()
  "Guesses a suitable module name from the path."
  (let* ((path (file-name-sans-extension buffer-file-name))
         (dirs (split-string path "/"))
         (lib (member "lib" dirs)))
    (if lib
        (mapconcat 'jeg2/camelize (cdr lib) ".")
      (jeg2/camelize (file-name-nondirectory path)))))
